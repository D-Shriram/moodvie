'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var client = require('@trpc/client');
var shared = require('@trpc/server/shared');

function createUseProxy(client) {
    return shared.createRecursiveProxy((opts)=>{
        const path = opts.path.join('.');
        return client.query(path, ...opts.args);
    });
}

function normalizePromiseArray(promise) {
    if (Array.isArray(promise)) {
        return Promise.all(promise);
    }
    return promise;
}
// ts-prune-ignore-next
function experimental_createTRPCNextAppDirClient(opts) {
    const client$1 = client.createTRPCUntypedClient(opts.config());
    const useProxy = createUseProxy(client$1);
    const cache = new Map();
    return shared.createFlatProxy((key)=>{
        if (key === 'use') {
            return (cb)=>{
                const promise = normalizePromiseArray(cb(useProxy));
                throw promise;
            // const [data, setData] = useState<unknown | unknown[]>();
            // useEffect(() => {
            //   const promise = normalizePromiseArray(cb(useProxy));
            //   void promise.then(setData).catch((err) => {
            //     throw err;
            //   });
            //   // eslint-disable-next-line react-hooks/exhaustive-deps
            // }, []);
            // return data;
            };
        }
        return shared.createRecursiveProxy(({ path , args  })=>{
            const pathCopy = [
                key,
                ...path
            ];
            const procedureType = client.clientCallTypeToProcedureType(pathCopy.pop());
            if (procedureType === 'query') {
                const queryCacheKey = JSON.stringify([
                    path,
                    args[0]
                ]);
                const cached = cache.get(queryCacheKey);
                if (cached?.promise) {
                    return cached.promise;
                }
            }
            const fullPath = pathCopy.join('.');
            const promise = client$1[procedureType](fullPath, ...args);
            if (procedureType !== 'query') {
                return promise;
            }
            const queryCacheKey1 = JSON.stringify([
                path,
                args[0]
            ]);
            cache.set(queryCacheKey1, {
                promise
            });
            return promise;
        });
    });
}

exports.experimental_createTRPCNextAppDirClient = experimental_createTRPCNextAppDirClient;
