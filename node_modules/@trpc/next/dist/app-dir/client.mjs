import { createTRPCUntypedClient, clientCallTypeToProcedureType } from '@trpc/client';
import { createRecursiveProxy, createFlatProxy } from '@trpc/server/shared';

function createUseProxy(client) {
    return createRecursiveProxy((opts)=>{
        const path = opts.path.join('.');
        return client.query(path, ...opts.args);
    });
}

function normalizePromiseArray(promise) {
    if (Array.isArray(promise)) {
        return Promise.all(promise);
    }
    return promise;
}
// ts-prune-ignore-next
function experimental_createTRPCNextAppDirClient(opts) {
    const client = createTRPCUntypedClient(opts.config());
    const useProxy = createUseProxy(client);
    const cache = new Map();
    return createFlatProxy((key)=>{
        if (key === 'use') {
            return (cb)=>{
                const promise = normalizePromiseArray(cb(useProxy));
                throw promise;
            // const [data, setData] = useState<unknown | unknown[]>();
            // useEffect(() => {
            //   const promise = normalizePromiseArray(cb(useProxy));
            //   void promise.then(setData).catch((err) => {
            //     throw err;
            //   });
            //   // eslint-disable-next-line react-hooks/exhaustive-deps
            // }, []);
            // return data;
            };
        }
        return createRecursiveProxy(({ path , args  })=>{
            const pathCopy = [
                key,
                ...path
            ];
            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
            if (procedureType === 'query') {
                const queryCacheKey = JSON.stringify([
                    path,
                    args[0]
                ]);
                const cached = cache.get(queryCacheKey);
                if (cached?.promise) {
                    return cached.promise;
                }
            }
            const fullPath = pathCopy.join('.');
            const promise = client[procedureType](fullPath, ...args);
            if (procedureType !== 'query') {
                return promise;
            }
            const queryCacheKey1 = JSON.stringify([
                path,
                args[0]
            ]);
            cache.set(queryCacheKey1, {
                promise
            });
            return promise;
        });
    });
}

export { experimental_createTRPCNextAppDirClient };
